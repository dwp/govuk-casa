/**
 * Represents the state of a user's journey through the Plan. It contains
 * information about:
 *
 * - Data gathered during the journey
 * - Validation errors on that data
 * - Navigation information about how the user got where they are
 */

const privates = new WeakMap();

class JourneyContext {
  /**
   * Constructor
   *
   * @param {object} data Entire journey data (indexed by page id)
   * @param {object} validation Page errors (indexed by page id)
   * @param {object} nav Navigation context
   */
  constructor(data = {}, validation = {}, nav = {}) {
    privates.set(this, { data, validation, nav });
  }

  /**
   * Turn this instance into an object that can be stringified.
   *
   * @returns {object} Plain object
   */
  toObject() {
    const self = privates.get(this);
    return Object.assign(Object.create(null), {
      data: this.getData(),
      validation: this.getValidationErrors(),
      nav: self.nav, // currently unused
    });
  }

  /**
   * Create a new JourneyContext using the plain object.
   *
   * @param {object} obj Object
   * @returns {JourneyContext} Instance
   */
  static fromObject(obj = {}) {
    return new JourneyContext(
      Object.prototype.hasOwnProperty.call(obj, 'data') ? obj.data : Object.create(null),
      Object.prototype.hasOwnProperty.call(obj, 'validation') ? obj.validation : Object.create(null),
      Object.prototype.hasOwnProperty.call(obj, 'nav') ? obj.nav : Object.create(null),
    );
  }

  get data() {
    return this.getData();
  }

  get validation() {
    return this.getValidationErrors();
  }

  /**
   * Return the data context.
   *
   * @return {object} Data context
   */
  getData() {
    return privates.get(this).data;
  }

  /**
   * Overwrite the data context with a new object.
   *
   * @param {object} data Data that will overwrite all existing data
   * @return {JourneyContext} Chain
   */
  setData(data) {
    const priv = privates.get(this);
    priv.data = data;
    privates.set(this, priv);
    return this;
  }

  /**
   * Get data context for a specific a specific page.
   *
   * @param  {string} pageId Page ID
   * @return {object} Page data
   */
  getDataForPage(pageId) {
    return privates.get(this).data[pageId];
  }

  /**
   * Overwrite data context for a specific page.
   *
   * @param {string} pageId Page ID
   * @param {object} data Data to overwrite with
   * @return {JourneyContext} Chain
   */
  setDataForPage(pageId, data) {
    const priv = privates.get(this);
    priv.data[pageId] = data;
    privates.set(this, priv);
    return this;
  }

  /**
   * Return validation errors for all pages.
   *
   * @return {object} All page validation errors
   */
  getValidationErrors() {
    return privates.get(this).validation;
  }

  /**
   * Clear any validation errors for the given page.
   *
   * @param {string} pageId Page ID
   * @return {JourneyContext} Chain
   */
  clearValidationErrorsForPage(pageId) {
    const priv = privates.get(this);
    delete priv.validation[pageId];
    privates.set(this, priv);
    return this;
  }

  /**
   * Set validation errors for a page.
   *
   * @param {string} pageId Page ID
   * @param {object} errors Errors index by field name (as generated by Validation.processor)
   * @return {JourneyContext} Chain
   */
  setValidationErrorsForPage(pageId, errors = {}) {
    const priv = privates.get(this);

    if (Object.prototype.toString.call(errors) !== '[object Object]') {
      throw new SyntaxError(`Errors must be an Object. Recieved ${Object.prototype.toString.call(errors)}`);
    }

    Object.keys(errors).forEach((k) => {
      if (!Array.isArray(errors[k])) {
        throw new SyntaxError('Field errors must be an array');
      }
    });

    priv.validation[pageId] = errors;

    privates.set(this, priv);
    return this;
  }

  /**
   * Return the validation errors associated with the page's currently held data
   * context (if any).
   *
   * @param {string} pageId Page ID
   * @return {object} An object of errors, indexed by field name
   */
  getValidationErrorsForPage(pageId) {
    return privates.get(this).validation[pageId] || Object.create(null);
  }

  /**
   * Determine whether the specified page has any errors in its validation
   * context.
   *
   * @param {string} pageId Page ID
   * @returns {boolean} Result
   */
  hasValidationErrorsForPage(pageId) {
    return Object.keys(this.getValidationErrorsForPage(pageId)).length > 0;
  }
}

module.exports = JourneyContext;
